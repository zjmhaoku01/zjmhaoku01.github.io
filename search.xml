<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Golang标准库学习：Context]]></title>
    <url>%2F2019%2F04%2F23%2FGolang%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0%EF%BC%9AContext%2F</url>
    <content type="text"><![CDATA[Context是什么？&emsp;&emsp;Context由Google官方开发，在Go1.7版本引入的标准库，也叫做上下文，在Go服务器程序中，每个请求都会有一个goroutine去处理。然而，处理程序往往还需要创建额外的goroutine去访问后端资源，比如数据库、RPC服务等。由于这些goroutine都是在处理同一个请求，所以它们往往需要访问一些共享的资源，比如用户身份信息、认证token、请求截止时间等。而且如果请求超时或者被取消后，所有的goroutine都应该马上退出并且释放相关的资源。Go提供了一个Context包，也就是上下文，来控制它们达到目的，本文我们来介绍Context包的基本使用方法。简单来说：就是用于有父子关系的goroutine之间来共享数据的一个空间。12345678910111213type Context interface &#123; // Deadline returns the time when work done on behalf of this context // should be canceled. Deadline returns ok==false when no deadline is // set. Deadline() (deadline time.Time, ok bool) // Done returns a channel that's closed when work done on behalf of this // context should be canceled. Done() &lt;-chan struct&#123;&#125; // Err returns a non-nil error value after Done is closed. Err() error // Value returns the value associated with this context for key. Value(key interface&#123;&#125;) interface&#123;&#125;&#125; 简单介绍一下其中的方法： Done会返回一个channel，当该context被取消的时候，该channel会被关闭，同时对应的使用该context的routine也应该结束并返回。 Context中的方法是协程安全的，这也就代表了在父routine中创建的context，可以传递给任意数量的routine并让他们同时访问。 Deadline会返回一个超时时间，routine获得了超时时间后，可以对某些io操作设定超时时间。 Value可以让routine共享一些数据，当然获得数据是协程安全的。 创建Context的六种方法方法一：context.Background() Context这个函数返回一个空 context。这只能用于高等级（在 main 或顶级请求处理中）1ctx := context.Background() 方法二：context.TODO() Context这个函数也是创建一个空 context。也只能用于高等级或当您不确定使用什么 context，或函数以后会更新以便接收一个 context 。这意味您（或维护者）计划将来要添加 context 到函数。1ctx := context.TODO() 有趣的是，查看代码，它与 background 完全相同。不同的是，静态分析工具可以使用它来验证 context 是否正确传递，这是一个重要的细节，因为静态分析工具可以帮助在早期发现潜在的错误，并且可以连接到 CI/CD 管道 方法三：context.WithValue(parent Context, key, val interface{}) (ctx Context, cancel CancelFunc)继承新建的context并赋值，此函数接收 context 并返回派生 context，其中值 val 与 key 关联，并通过 context 树与 context 一起传递。这意味着一旦获得带有值的 context，从中派生的任何 context 都会获得此值。不建议使用 context 值传递关键参数，而是函数应接收签名中的那些值，使其显式化。1ctx := context.WithValue(context.Background(), key, "test") 方法四：context.WithCancel(parent Context) (ctx Context, cancel CancelFunc)这是它开始变得有趣的地方。此函数创建从传入的父 context 派生的新 context。父 context 可以是后台 context 或传递给函数的 context。 返回派生 context 和取消函数。只有创建它的函数才能调用取消函数来取消此 context。如果您愿意，可以传递取消函数，但是，强烈建议不要这样做。这可能导致取消函数的调用者没有意识到取消 context 的下游影响。可能存在源自此的其他 context，这可能导致程序以意外的方式运行。简而言之，永远不要传递取消函数。1ctx := context.WithValue(context.Background(), key, "test") 在子goroutine中可以使用select &lt;-ctx.Done(): 来判断父goroutine是否调用来取消函数。123456789101112go func Println(ctx, a, b) &#123; for &#123; fmt.Println(a + b) a, b = a+1, b+1 select &#123; case &lt;-ctx.Done(): fmt.Println("程序结束") return default: &#125; &#125;&#125;() 方法五：context.WithDeadline(parent Context, d time.Time) (ctx Context, cancel CancelFunc)当然也可以创建一个限时的context，一旦到截止时间会自动调用取消函数。此函数返回其父项的派生 context，当截止日期超过或取消函数被调用时，该 context 将被取消。例如，您可以创建一个将在以后的某个时间自动取消的 context，并在子函数中传递它。当因为截止日期耗尽而取消该 context 时，获此 context 的所有函数都会收到通知去停止运行并返回。1ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(2 * time.Second)) 方法六：context.WithTimeout(parent Context, timeout time.Duration) (ctx Context, cancel CancelFunc)此函数类似于 context.WithDeadline。不同之处在于它将持续时间作为参数输入而不是时间对象。此函数返回派生 context，如果调用取消函数或超出超时持续时间，则会取消该派生 context。1ctx, cancel := context.WithTimeout(context.Background(), 2 * time.Second) 使用Context来看一个简单Context库使用例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( "context" "fmt" "time")func Println(ctx context.Context, a, b int) &#123; for &#123; fmt.Println(a + b) a, b = a+1, b+1 select &#123; case &lt;-ctx.Done(): fmt.Println("程序结束") return default: &#125; &#125;&#125;func main() &#123; &#123; // 超时取消 a := 1 b := 2 timeout := 2 * time.Second ctxBg := context.Background() ctx, _ := context.WithTimeout(ctxBg, timeout) Println(ctx, a, b) time.Sleep(2 * time.Second) // 等待时候还会继续输出 &#125; &#123; // 手动取消 a := 1 b := 2 ctx, cancelCtx := context.WithCancel(context.Background()) go func() &#123; time.Sleep(2 * time.Second) cancelCtx() // 在调用处主动取消 &#125;() Println(ctx, a, b) time.Sleep(2 * time.Second) &#125;&#125; &emsp;&emsp;父goroutine一般会把context当作参数传给子goroutine，因此父goroutine可以控制context来控制所有子孙goroutine。再看一个WithValue的例子：123456789101112131415161718192021222324252627282930313233343536package mainimport ( "context" "fmt" "time")var key string = "name"func main() &#123; ctx, cancel := context.WithCancel(context.Background()) //附加值 valueCtx := context.WithValue(ctx, key, "【监控1】") go watch(valueCtx) time.Sleep(10 * time.Second) fmt.Println("可以了，通知监控停止") cancel() //为了检测监控过是否停止，如果没有监控输出，就表示停止了 time.Sleep(5 * time.Second)&#125;func watch(ctx context.Context) &#123; for &#123; select &#123; case &lt;-ctx.Done(): //取出值 fmt.Println(ctx.Value(key), "监控退出，停止了...") return default: //取出值 fmt.Println(ctx.Value(key), "goroutine监控中...") time.Sleep(2 * time.Second) &#125; &#125;&#125; Context使用原则 不要把Context放在结构体中，要以参数的方式传递 以Context作为参数的函数方法，应该把Context作为第一个参数，放在第一位。 给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO Context的Value相关方法应该传递必须的数据，不要什么数据都使用这个传递 Context是线程安全的，可以放心的在多个goroutine中传递 Context库代码总结为了记忆，所以把Context常用使用方法记录了下来：1234567891011121314151617181920212223242526272829package mainimport ( "context" "time")// Context包定义了上下文类型func main() &#123; // 返回一个不是nil的空的Context。当不清楚使用哪个Context或者不可用时（因为功能尚未扩展到接受Context参数）。 context.TODO() // 返回一个不是nil的空Context。它永远不会被取消，没有值，也没有存活时间。 它通常由主函数，初始化和测试使用，并作为传入请求的顶级Context。 ctx := context.Background() // 根据Context，返回一个Context副本和一个取消方法，以方便完成工作后释放资源 _, cancel := context.WithCancel(ctx) defer cancel() // 根据Context和最迟存活时间，返回一个Context副本和一个取消方法，以方便完成工作后释放资源 context.WithDeadline(ctx, time.Now().Add(50 * time.Millisecond)) // 根据Context和超时时间，返回一个Context副本和一个取消方法，以方便完成工作后释放资源 context.WithTimeout(ctx, time.Millisecond * 50) // 给Context添加自定义类型的键值对，返回一个新的Context context.WithValue(ctx, "language", "Go")&#125;]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
